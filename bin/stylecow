#!/usr/bin/env node

var program = require('commander');
var fs = require('fs');
var path = require('path');
var findup = require('findup-sync');

var stylecow = findup('node_modules/stylecow/lib/index.js');

if (stylecow) {
	stylecow = require(stylecow);
}

program.version(require('../package.json').version);


// EXECUTE

program
	.command('execute [<config>]')
	.description('converts the css using a config file (by default "./stylecow.json")')
	.option('-i, --input <file>', 'Use a specific input file instead the defined in the config file')
	.option('-o, --output <file>', 'Use a specific output file instead the defined in the config file')
	.option('-c, --code <name>', 'Use a specific code style instead the defined in the config file')
	.option('-w, --watch', 'watches the changes in the input css files')
	.action(function (configFile, command) {
		if (!stylecow) {
			console.log('');
			console.log('  error: Unable to find stylecow');
			console.log('');
			return;
		}

		configFile = path.resolve(process.cwd(), configFile || './stylecow.json');

		var config = readConfig(configFile),
			basePath = path.dirname(configFile),
			input, output, code;

		input = command.input || config.input;

		if (!input) {
			console.log('');
			console.log('  error: No input file defined');
			console.log('');
			return;
		}

		input = path.resolve(basePath, input);

		if (!fs.existsSync(input)) {
			console.log('');
			console.log('  error: Input file `' + input + '` not found');
			console.log('');
			return;
		}

		output = command.output || config.output;

		if (output) {
			output = path.resolve(basePath, output);
		}

		if (command.code) {
			config.code = command.code;
		}

		stylecow.setConfig(config);

		if (fs.lstatSync(input).isFile()) {
			return convert(input, output, command.watch);
		}

		if (fs.lstatSync(input).isDirectory()) {
			var glob = require('glob');

			return glob('**/*.css', { cwd: path.resolve(input) }, function (er, files) {
				files.forEach(function (file) {
					convert(path.join(input, file), output ? path.join(output, file) : null, command.watch);
				});
			});
		}
	});


function convert (input, output, watch) {
	var css = stylecow.convertFromFile(input);

	if (output) {
		var dir = path.dirname(output);

		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir);
		}

		fs.writeFileSync(output, css.toCode());

		console.log('success: Generated "' + output + '"');
	} else {
		console.log('');
		console.log(css.toCode());
		console.log('');
	}

	if (watch) {
		console.log('Waiting for changes...');
		console.log('');
		
		css.files.forEach(function (file) {
			fs.watchFile(file, {persistent: true, interval: 2000}, function (curr, prev) {
				if (curr.mtime !== prev.mtime) {
					console.log('changed detected: ' + file);
					console.log('');
					
					css.files.forEach(function (f) {
						fs.unwatchFile(f);
					});

					convert(input, output, watch);
				}
			});
		});
	}
}


// CONFIG

program
	.command('init [<config>]')
	.description('Creates a new configuration file')
	.action(function config (configFile, command) {
		var defaults = defaultConfig(configFile);

		modifyConfig(defaults, function (config, file) {
			writeConfig(config, file);
		});
	});


// No available command

program.command('*').action(function (command) {
	console.log('');
	console.log('  error: unknown command `' + command + '`');
	console.log('');
	console.log('  type stylecow -h for help');
	console.log('');
});



// Misc

function modifyConfig (config, callback) {
	var inquirer = require('inquirer');

	var questions = [
		{
			type: "input",
			name: "explorer",
			message: "Min version supported in Internet Explorer",
			default: config.support.explorer
		},
		{
			type: "input",
			name: "firefox",
			message: "Min version supported in Mozilla Firefox",
			default: config.support.firefox
		},
		{
			type: "input",
			name: "chrome",
			message: "Min version supported in Google Chrome",
			default: config.support.chrome
		},
		{
			type: "input",
			name: "safari",
			message: "Min version supported in Safari",
			default: config.support.safari
		},
		{
			type: "input",
			name: "opera",
			message: "Min version supported in Opera",
			default: config.support.opera
		},
		{
			type: "input",
			name: "android",
			message: "Min version supported in Android",
			default: config.support.android
		},
		{
			type: "input",
			name: "ios",
			message: "Min version supported in Safari for iOS",
			default: config.support.ios
		},
		{
			type: "list",
			name: "code",
			message: "Code style used to generate the css",
			choices: config.codeStyles,
			default: config.code
		},
		{
			type: "input",
			name: "plugins",
			message: "Plugins used to transform de css (comma separated)",
			default: config.plugins.join(','),
			filter: function (value) {
				return value ? value.split(',') : [];
			}
		},
		{
			type: "input",
			name: "input",
			message: "Input css filename or directory (optional)"
		},
		{
			type: "input",
			name: "output",
			message: "Output css filename or directory (optional)"
		}
	];

	inquirer.prompt(questions, function (answers) {
		var newConfig = {};

		if (answers.input) {
			newConfig.input = answers.input;
		}

		if (answers.output) {
			newConfig.output = answers.output;
		}

		newConfig.support = {};

		['explorer','firefox','chrome','safari','opera','android','ios'].forEach(function (browser) {
			newConfig.support[browser] = (answers[browser] === 'false') ? false : parseFloat(answers[browser], 10);
		});

		newConfig.plugins = answers.plugins;
		newConfig.code = answers.code;

		console.log(JSON.stringify(newConfig, null, '\t'));

		inquirer.prompt([
			{
				type: "confirm",
				name: "ok",
				message: "Looks fine?"
			}
		], function (answers) {
			if (answers.ok) {
				inquirer.prompt([
					{
						type: "input",
						name: "file",
						message: "Filename where to save the configuration",
						validate: function (e) {
							if (!e) {
								return 'You must specify a filename to the config file (for example: myconfig.json)';
							}

							if (path.extname(e) !== '.json') {
								return 'The config file must end in ".json"';
							}

							return true;
						},
						default: 'stylecow.json'
					}
				], function (answers) {
					callback(newConfig, answers.file);
				});
			}
		});
	});
}

function readConfig (file) {
	if (fs.existsSync(file)) {
		return require(file);
	}

	console.log('');
	console.log('  error: Config file `' + file + '` not found');
	console.log('');

	process.exit();
}

function writeConfig (value, file) {
	fs.writeFileSync(file, JSON.stringify(value, null, '\t'));

	console.log('success: Config file saved: `' + file + '`');
	console.log('');
}

function defaultConfig (file) {
	var codeStyles = ["normal", "minify"], defaults;

	if (file) {
		defaults = readConfig(configFile = path.resolve(process.cwd(), file));
		defaults.codeStyles = codeStyles;

		return defaults;
	}

	//Default values
	defaults = {
		code: "normal",
		support: {
			"explorer": 8.0,
			"firefox": 30.0,
			"chrome": 35.0,
			"safari": 6.0,
			"opera": 22.0,
			"android": 4.0,
			"ios": 6.0
		},
		plugins: [],
		codeStyles: codeStyles
	};

	//Search for installed stylecow and plugins
	var node_modules = findup('node_modules/');

	if (node_modules) {
		var pluginPrefix = 'stylecow-plugin-';

		if (stylecow) {
			defaults = stylecow.defaults;
			defaults.codeStyles = Object.keys(stylecow.codeStyles);
			pluginPrefix = stylecow.pluginPrefix;
		}

		var len = pluginPrefix.length;

		defaults.plugins = fs.readdirSync(node_modules).filter(function (value) {
				return value.slice(0, len) === pluginPrefix;
			}).map(function (value) {
				return value.slice(len);
			}).sort();
	}
}

program.parse(process.argv);

if (program.args.length === 0) {
	program.help();
}
